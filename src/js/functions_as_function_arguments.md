# Функции как аргументы функций

Функции можно не только объявлять и вызывать, но и использовать так же, как значения любых других типов. Например, функцию можно присвоить в переменную.

```js
const newAlert = alert;
newAlert("Hello");  // Выводит: Hello
```

Также функцию можно передать в качестве аргумента другой функции. Например, можно попробовать при помощи функции `alert` вывести на экран саму функцию `alert`, тогда JavaScript попытает сконвертировать её в строку и отобразить. Результат может различаться между браузерами.

```js
alert(alert);  // Выводит: function alert() { [native code] }
```

Пример выше не представляет практического интереса, но вообще передача функции в качестве аргумента другой функции может быть полезна, так как это позволяет при вызове функции через аргументы настроить не только какие-то значения, которые использует функция, но и часть самого алгоритма функции.

В JavaScript есть много встроенных функций и методов, которые в качестве одного из параметров принимают функцию. Далее рассмотрим несколько примеров.

### Метод массивов `map`

Метод `map` возвращает новый массив, состоящий из результатов вызова заданной функции для каждого элемента исходного массива.

```js
function square(x) {
    return x ** 2;
}

[1, 2, 3].map(square);            // Возвращает: [1, 4, 9]
["1", "2", "three"].map(Number);  // Возвращает: [1, 2, NaN]
```

### Метод массивов `filter`

Метод `filter` возвращает новый массив, состоящий только из тех элементов исходного массива, для которых заданная функция возвращает правдивое значение.

```js
function isPositive(x) {
    return x > 0;
}

[0, 1, -1, 2, -2].filter(isPositive);  // Возвращает: [1, 2]
```

### Метод массивов `every`

Метод `every` возвращает `true`, если заданная функция возвращает правдивое значение для каждого элемента массива, и `false` в остальных случаях.

```js
function isPositive(x) {
    return x > 0;
}

[1, 2, 3].every(isPositive);   // Возвращает: true
[0, 1, -1].every(isPositive);  // Возвращает: false
```

### Метод массивов `some`

Метод `some` возвращает `true`, если заданная функция возвращает правдивое значение хотя бы для одного элемента массива.

```js
function isPositive(x) {
    return x > 0;
}

[0, 1, -1].some(isPositive);   // Возвращает: true
[0, -1, -2].some(isPositive);  // Возвращает: false
```

### Метод массивов `sort`

Метод `sort` сортирует элементы массива по возрастанию. По умолчанию элементы сравниваются, как если бы они были строками, поэтому сортировка происходит по алфавиту.

```js
const a = [11, 12, 1, 2];
a.sort();
a;  // Возвращает: [1, 11, 12, 2]
```

Чтобы настроить, по какому критерию происходит сортировка, в метод `sort` можно передать функцию, сравнивающую два произвольных элемента массива. Функция должна принимать значения двух элементов и возвращать отрицательное число, если первый меньше, положительное, если первый больше, и `0`, если элементы равны.

```js
function compareNumbers(first, second) {
    return first - second;
}

const a = [11, 12, 1, 2];
a.sort(compareNumbers);
a;  // Возвращает: [1, 2, 11, 12]
```

Обратим внимание, что метод `sort` меняет порядок элементов в исходном массиве, нового массива не создаётся.

## Упражнения

1. Напиши программу, которая принимает на вход список разделённых запятыми строк и выводит два способа сортировки этого списка: по алфавиту и по длине слова.

1. Напиши программу для поиска "длинных" слов в предложении текста. Программа принимает на вход произвольное предложение и выводит через запятую только те слова, которые длиннее 10 символов. Для упрощения можно считать, что знаков пунктуации в предложении нет. Нельзя использовать циклы.

1. В неком сервисе каршеринга на протяжении поездки через равные промежутки времени измеряется скорость автомобиля. После поездки приложение проверяет, не превышал ли водитель ограничение скорости в 60 км/ч, и показывает либо сообщение `Спасибо, что ездите по правилам!`, либо `Вы превышали ограничение скорости! Это опасно и может стать причиной штрафа`.

    Напиши скрипт для приложения каршеринга, который получает на вход список разделённых через запятую измерений скорости в км/ч и выводит нужное сообщение. Нельзя использовать циклы.

1. В пиццерии собрали массив данных по приготовленным пиццам за смену. Каждый i-й элемент массива — затраченное на приготовление i-й пиццы время в формате `<минуты>:<секунды>`.

    ```js
    [
        "13:47", "17:04", "16:04", "13:28", "00:10",
        "15:14", "13:00", "15:52", "13:07", "14:56",
        "32:27", "14:18", "15:25", "12:11", "13:25",
        "16:50", "13:07", "17:17", "15:21", "12:18",
        "17:52", "13:34", "14:31", "47:36", "16:02",
        "01:53", "14:42", "13:26", "12:10", "15:45",
        "04:38", "12:33", "14:56", "14:50", "13:20",
        "12:03", "13:11", "16:44", "16:50", "17:11",
        "16:20", "15:42", "16:42", "15:54", "16:39",
        "15:46", "14:59", "16:20", "13:48", "14:51",
    ]
    ```

    Требуется посчитать среднее время приготовления одной пиццы. При этом в данных встречаются аномалии, поэтому при расчётах не нужно учитывать 10% самых быстрых и 10% самых медленных приготовлений.
